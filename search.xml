<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring 依赖注入（DI）</title>
      <link href="/2025/08/28/Spring-DI/"/>
      <url>/2025/08/28/Spring-DI/</url>
      
        <content type="html"><![CDATA[<h1 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h1><p>在 Spring 中，依赖注入（Dependency Injection, DI）是核心特性。它通过 IoC 容器管理 Bean 的依赖关系，从而避免手动 new 对象，提升了代码的解耦性和可维护性。</p><hr><h2 id="2-1-Autowired-自动装配"><a href="#2-1-Autowired-自动装配" class="headerlink" title="2.1 @Autowired 自动装配"></a>2.1 @Autowired 自动装配</h2><p>@Autowired 是 Spring 提供的注解，用于让容器自动完成依赖注入。</p><p>要实现自动注入，不一定非要写 @Autowired，因为 Spring 在某些场景下会自动完成：</p><ul><li>@Bean 方法的参数会自动注入</li><li>构造函数的参数会自动注入</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>构造函数</p><ul><li>如果 Bean 只有一个有参构造函数，即使省略 @Autowired，Spring 也会自动注入参数</li><li>如果有多个有参构造函数，且没有无参构造函数，会报错。此时需要用 @Autowired 明确指定</li><li>构造函数上的 required 属性会失效</li></ul><p>参数</p><ul><li>如果想设置某个构造函数参数不是必须的，可以单独标记</li><li>在单元测试中也可以直接对方法参数使用</li></ul><p>方法</p><ul><li>Spring 会自动调用被 @Autowired 标记的方法，并完成参数注入</li></ul><p>装配规则</p><ul><li>Spring 会先根据 <strong>类型</strong> 去容器中查找 (byType)</li><li>如果有多个同类型的 Bean，再根据 <strong>名字</strong> 查找 (byName)</li><li>如果还是找不到，可以通过以下方式解决：<ul><li>使用 @Primary 指定某个 Bean 为主要候选</li><li>使用 @Qualifier(“beanName”) 指定 Bean 的名字</li></ul></li></ul><p>容错处理</p><ul><li>如果容器中一个都没找到，会报错</li><li>可以通过 @Autowired(required &#x3D; false) 避免报错</li></ul><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class OrderService &#123;</span><br><span class="line">    private final UserService userService;</span><br><span class="line"></span><br><span class="line">    // 推荐：构造函数注入</span><br><span class="line">    @Autowired</span><br><span class="line">    public OrderService(UserService userService) &#123;</span><br><span class="line">        this.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方法注入</span><br><span class="line">    @Autowired</span><br><span class="line">    public void init(PaymentService paymentService) &#123;</span><br><span class="line">        System.out.println(&quot;支付服务已注入: &quot; + paymentService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class UserService &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Primary</span><br><span class="line">public class PaymentService &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class PaymentServiceV2 &#123;&#125;</span><br><span class="line">@Service</span><br><span class="line">public class TestService &#123;</span><br><span class="line">    // 使用 @Qualifier 指定注入哪个 Bean</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;paymentServiceV2&quot;)</span><br><span class="line">    private PaymentService paymentService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-Inject-和-Resource"><a href="#2-2-Inject-和-Resource" class="headerlink" title="2.2 @Inject 和 @Resource"></a>2.2 @Inject 和 @Resource</h2><p>除了 @Autowired，我们还可以使用 JDK 提供的注解。</p><h3 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h3><ul><li>JSR-330 标准</li><li>和 @Autowired 类似，但不能设置 required &#x3D; false</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import javax.inject.Inject;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class BookService &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    private UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><ul><li>JSR-250 标准</li><li>先根据名字查找，再根据类型查找</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class BlogService &#123;</span><br><span class="line">    @Resource(name = &quot;userService&quot;)</span><br><span class="line">    private UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IDEA-为什么不建议在字段上使用-Autowired"><a href="#IDEA-为什么不建议在字段上使用-Autowired" class="headerlink" title="IDEA 为什么不建议在字段上使用 @Autowired"></a>IDEA 为什么不建议在字段上使用 @Autowired</h3><ol><li>字段通常是 private，通过 @Autowired 注入会破坏封装性</li><li>依赖注入应通过构造函数或方法完成，便于单元测试和维护</li></ol><p>推荐的做法：</p><ul><li>使用构造函数注入（最推荐）</li><li>使用 @Resource 指定 Bean</li><li>在字段上用 @Autowired 也不是错误，但不够优雅</li></ul><hr><h2 id="2-3-Value"><a href="#2-3-Value" class="headerlink" title="2.3 @Value"></a>2.3 @Value</h2><p>@Value 用于给字段注入值，可以是常量、配置文件中的属性，或者表达式。</p><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>直接赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;ceshi&quot;)</span><br><span class="line">private String name;</span><br></pre></td></tr></table></figure><p>引用配置文件属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># application.properties</span><br><span class="line">user.age=20</span><br><span class="line">@Value(&quot;$&#123;user.age&#125;&quot;)</span><br><span class="line">private Integer age;</span><br></pre></td></tr></table></figure><p>外部配置文件（非 Spring Boot）：<br> 需要通过 @PropertySource 指定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@PropertySource(&quot;classpath:xushu.properties&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    @Value(&quot;$&#123;xushu.name&#125;&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    @Value(&quot;$&#123;xushu.age&#125;&quot;)</span><br><span class="line">    private Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;user.address:默认地址&#125;&quot;)</span><br><span class="line">private String address;</span><br></pre></td></tr></table></figure><p>SpEL 表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;#&#123;1+2&#125;&quot;)</span><br><span class="line">private Integer sum;</span><br><span class="line"></span><br><span class="line">@Value(&quot;#&#123;T(java.lang.Math).random() * 100&#125;&quot;)</span><br><span class="line">private Double random;</span><br><span class="line"></span><br><span class="line">@Value(&quot;#&#123;user.age &gt; 18 ? &#x27;成年人&#x27; : &#x27;未成年&#x27;&#125;&quot;)</span><br><span class="line">private String status;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>依赖注入的推荐做法：</p><ul><li>优先使用构造函数注入，保证依赖的不可变性和可测试性</li><li>在 Bean 选择时，合理使用 @Primary 或 @Qualifier</li><li>配置值注入用 @Value，支持默认值和 SpEL 表达式</li><li>@Autowired 和 @Inject&#x2F;@Resource 都可以用，根据习惯或团队规范选择</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> IoC </tag>
            
            <tag> DI </tag>
            
            <tag> Autowired </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean</title>
      <link href="/2025/08/28/Spring-Bean/"/>
      <url>/2025/08/28/Spring-Bean/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-Bean-笔记"><a href="#Spring-Boot-Bean-笔记" class="headerlink" title="Spring Boot Bean 笔记"></a>Spring Boot Bean 笔记</h1><h2 id="Bean-的定义方式"><a href="#Bean-的定义方式" class="headerlink" title="Bean 的定义方式"></a>Bean 的定义方式</h2><p>Bean 本质上就是被 Spring 容器管理的对象。常见定义方式有：</p><p><strong>一、XML 配置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.example.UserService&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li>容器启动时读取 XML 文件，将 &#96;&#96; 对应的类实例化为 Bean</li><li>支持属性注入和构造器注入</li><li>优点：明确可控；缺点：配置繁琐，可维护性差</li></ul><hr><p><strong>二、注解方式</strong></p><ul><li><code>@Component</code>：通用注解</li><li>语义化注解：<ul><li><code>@Service</code>：标注 Service 层</li><li><code>@Repository</code>：标注 Dao 层</li><li><code>@Controller</code> &#x2F; <code>@RestController</code>：标注 Web 层</li></ul></li><li><code>@Configuration</code>：标注配置类，可定义 <code>@Bean</code> 方法</li></ul><p><strong>自动扫描 Bean</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan(&quot;com.xs&quot;)</span><br></pre></td></tr></table></figure><ul><li>扫描指定包及其子包下的组件类，将标注了组件注解的类自动注册为 Bean</li><li>Spring Boot 项目中，如果启动类在根包下，默认会扫描启动类所在包及子包，无需显式写 <code>@ComponentScan</code></li><li>和 <code>@Bean</code> 手动注册方式可以共存</li></ul><hr><p><strong>三、@Bean 注解方式</strong></p><ul><li>标注在方法上</li><li>必须写在 <code>@Configuration</code> 配置类里</li></ul><p>特点：</p><ul><li>一个 <code>@Bean</code> 方法调用另一个 <code>@Bean</code> 方法时，Spring 会从容器中获取，而不是重新 new</li><li>可以干预第三方类，把外部类手动注册为 Bean</li><li>方法参数会自动装配其他 Bean</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userService() &#123;</span><br><span class="line">        return new UserService(&quot;custom&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>四、@Import 注解</strong></p><ul><li>标注在类上</li><li>导入的类会被注册为 Bean</li></ul><p>用法：</p><ol><li><strong>直接导入普通类</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Import(UserService.class)</span><br></pre></td></tr></table></figure><ol><li><strong>ImportSelector</strong></li></ol><ul><li>实现 <code>ImportSelector</code> 接口</li><li>重写 <code>selectImports()</code> 返回类的全限定名数组</li><li>支持批量注入 Bean</li></ul><ol><li><strong>ImportBeanDefinitionRegistrar</strong></li></ol><ul><li>实现 <code>ImportBeanDefinitionRegistrar</code> 接口</li><li>手动操作 <code>BeanDefinitionRegistry</code> 注册 Bean</li><li>适用于动态或复杂场景</li></ul><hr><h2 id="Bean-的实例化方式"><a href="#Bean-的实例化方式" class="headerlink" title="Bean 的实例化方式"></a>Bean 的实例化方式</h2><p><strong>一、无参构造函数（默认方式）</strong></p><ul><li>如果类有无参构造函数，Spring 会优先使用它</li><li>如果类只有一个有参构造函数，Spring 会尝试自动装配参数</li><li>如果有多个有参构造函数且没有无参构造函数，会报错</li></ul><hr><p><strong>二、实例工厂方法（配合 @Bean）</strong></p><ul><li>在配置类里写工厂方法</li><li>可以自由选择构造函数</li><li>支持依赖注入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userService() &#123;</span><br><span class="line">        return new UserService(&quot;custom&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>三、FactoryBean（特殊 Bean）</strong></p><ul><li><code>FactoryBean</code> 是一个接口</li><li>实现它的类本身就是“工厂”，用来生产 Bean</li><li>必须实现：<ul><li><code>getObject()</code>：返回真正的 Bean</li><li><code>getObjectType()</code>：返回 Bean 类型信息</li></ul></li></ul><p>特点：</p><ul><li>容器中通过名字获取时拿到的是 <code>getObject()</code> 返回的对象</li><li>想获取工厂本身，需要名字前加 <code>&amp;</code></li></ul><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><strong>BeanDefinition</strong> 是蓝图，描述 Bean 的信息</li><li><strong>Bean</strong> 是实例，由容器管理</li><li><strong>定义 Bean</strong> 的方式：XML、注解、JavaConfig、@Import</li><li><strong>实例化 Bean</strong> 的方式：构造器、工厂方法、FactoryBean</li><li><strong>自动扫描 Bean</strong>：通过 <code>@ComponentScan</code> 或 Spring Boot 默认扫描</li></ul><table><thead><tr><th>注册方式</th><th>是否需要类注解</th><th>实例化方式</th><th>适用场景</th></tr></thead><tbody><tr><td>XML 配置</td><td>不需要</td><td>构造器 &#x2F; 工厂方法</td><td>老项目或第三方系统，配置明确可控</td></tr><tr><td>注解 + @ComponentScan</td><td>需要</td><td>构造器 &#x2F; 工厂方法</td><td>Spring Boot 自动扫描，省去手动注册</td></tr><tr><td>@Bean 方法</td><td>不需要</td><td>工厂方法 &#x2F; 构造器</td><td>第三方类或需要自定义初始化逻辑</td></tr><tr><td>@Import 注解</td><td>不需要</td><td>构造器 &#x2F; 工厂方法</td><td>动态或批量注册 Bean，注册第三方类或复杂场景</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> IoC </tag>
            
            <tag> Bean </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
